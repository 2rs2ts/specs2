package org.specs2
package html

import control._
import specification.core._
import scala.xml._
import io._
import NodeSeq._
import xml.Nodex._
import Htmlx._
import data.Trees._

import scalaz.Tree

/**
 * This trait checks for the presence of a <toc/> tag at the beginning of a xml document and replaces it
 * by a list of links to the headers of the document
 */
trait TableOfContents {

  /** create a table of contents for all the specifications */
  def createToc(specifications: List[SpecificationStructure], outDir: DirectoryPath, fileSystem: FileSystem): Action[Unit] = for {
    pages   <- readHtmlPages(specifications, outDir, fileSystem)
    toc     =  createToc(pages)
    _       <- saveHtmlPages(pages map addToc(toc), fileSystem)
  } yield ()

  def readHtmlPages(specifications: List[SpecificationStructure], outDir: DirectoryPath, fileSystem: FileSystem): Action[Tree[SpecHtmlPage]] = ???

  /**
   * @return add a toc to each HtmlFile where relevant
   */
  def addToc(toc: NodeSeq): SpecHtmlPage =>  SpecHtmlPage = ???

  def createToc(pages: Tree[SpecHtmlPage]): NodeSeq = {
    ???
//    val root = htmlFiles.rootLabel
//    def tocItems(tree: Tree[HtmlLinesFile]): NodeSeq = {
//      val current = tree.rootLabel
//      tocItemList(body    = current.printLines(output).xml,
//        rootUrl = root.link.url,
//        url     = current.link.url,
//        id      = current.specId,
//        subTocs = Map(tree.subForest.map(subSpec => (subSpec.rootLabel.specId, tocItems(subSpec))):_*))
//    }
//    // add a toc only where a parent file defines it
//    // and propagate the same toc to the children
//    if ((args <| root.args).report.hasToc) {
//      val rootToc = TreeToc(root.specId, tocItems(htmlFiles))
//      root.copy(toc = rootToc) +: htmlFiles.subForest.flatMap(_.flatten).map(_.copy(toc = rootToc)).toSeq
//    }
//    else
//      root +: htmlFiles.subForest.flatMap(addToc).toSeq
  }


  def saveHtmlPages(pages: Tree[SpecHtmlPage], fileSystem: FileSystem): Action[Unit] = ???

  /**
   * Create a Table of contents by building a Tree of all the header elements contained into the "body" and mapping it to an <ul/> list
   *
   * The body can contain <subtoc id="something"/> elements showing where to insert sub-table of contents corresponding to linked documents
   *
   * @param body html where to extract the table of contents
   * @param url of the document linked to the root of the toc
   * @param id of the specification that is the root of the toc (it is used to "open" the toc list on the current specification).
   *        This id is generated by the specification SpecName
   * @param subTocs map of identifier -> toc for the sub-specifications. The subtocs are inserted where the <subtoc/> tag in present in the body
   *
   * @return the toc of a document
   */
  def tocItemList(body: NodeSeq, rootUrl: DirectoryPath, url: String, id: SpecId, subTocs: Map[SpecId, NodeSeq]): NodeSeq = {
    body.headersTree.
      bottomUp { (h: Header, s: Stream[NodeSeq]) =>
        if (h.isRoot)
      // 'id' is the name of the attribute expected by jstree to "open" the tree on a specific node
          s.reduceNodes.updateHeadAttribute("id", id.toString)
        else if (h.isSubtoc)
          subTocs.getOrElse(h.specId, Empty) ++ s.reduceNodes
        else
          <li id={h.specId.toString}><a href={FilePath.unsafe(h.anchorName(url)).relativeTo(rootUrl).path}>{h.name}</a>
            { <ul>{s.toSeq}</ul> unless s.toSeq.isEmpty }
          </li>
    }.rootLabel
  }
}

object TableOfContents extends TableOfContents
