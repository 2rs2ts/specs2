package org.specs2
package html

import control._
import specification.core._
import scala.xml.NodeSeq
import io._
import xml.Nodex._
import Htmlx._
import data.Trees._
import scalaz._, Scalaz._

/**
 * This trait checks for the presence of a <toc/> tag at the beginning of a xml document and replaces it
 * by a list of links to the headers of the document
 */
trait TableOfContents {

  /** create a table of contents for all the specifications */
  def createToc(specifications: List[SpecStructure], outDir: DirectoryPath, fileSystem: FileSystem): Action[Unit] = for {
    pages   <- readHtmlPages(specifications, outDir, fileSystem)
    toc     =  createToc(pages)
    _       <- saveHtmlPages(pages.map(_.addToc(toc)), fileSystem)
  } yield ()

  /** read the generated html pages and return them as a tree, based on the links relationships between them */
  def readHtmlPages(specifications: List[SpecStructure], outDir: DirectoryPath, fileSystem: FileSystem): Action[List[SpecHtmlPage]] =
    for {
      paths <- fileSystem.listFilePaths(outDir)
      pages <- createSpecPages(paths.toList, specifications, outDir, fileSystem)
    } yield pages

  def createSpecPages(paths: List[FilePath], specifications: List[SpecStructure], outDir: DirectoryPath, fileSystem: FileSystem): Action[List[SpecHtmlPage]] = {
    val expectedFiles = specifications.map(s => SpecHtmlPage.outputPath(outDir, s))
    paths.filter(expectedFiles.contains).map { path =>
      fileSystem.readFile(path).map(content => SpecHtmlPage(path, content))
    }.sequenceU
  }

  def createToc(pages: List[SpecHtmlPage]): NodeSeq = {
    pages.map(_.createSubtoc).reduceNodes

//    val root = htmlFiles.rootLabel
//    def tocItems(tree: Tree[HtmlLinesFile]): NodeSeq = {
//      val current = tree.rootLabel
//      tocItemList(body    = current.printLines(output).xml,
//        rootUrl = root.link.url,
//        url     = current.link.url,
//        id      = current.specId,
//        subTocs = Map(tree.subForest.map(subSpec => (subSpec.rootLabel.specId, tocItems(subSpec))):_*))
//    }
//    // add a toc only where a parent file defines it
//    // and propagate the same toc to the children
//    if ((args <| root.args).report.hasToc) {
//      val rootToc = TreeToc(root.specId, tocItems(htmlFiles))
//      root.copy(toc = rootToc) +: htmlFiles.subForest.flatMap(_.flatten).map(_.copy(toc = rootToc)).toSeq
//    }
//    else
//      root +: htmlFiles.subForest.flatMap(addToc).toSeq
  }


  def saveHtmlPages(pages: List[SpecHtmlPage], fileSystem: FileSystem): Action[Unit] =
    pages.map(page => fileSystem.writeFile(page.path, page.content)).sequenceU.void

  /**
   * Create a Table of contents by building a Tree of all the header elements contained into the "body" and mapping it to an <ul/> list
   *
   * The body can contain <subtoc id="something"/> elements showing where to insert sub-table of contents corresponding to linked documents
   *
   * @param body html where to extract the table of contents
   * @param url of the document linked to the root of the toc
   * @param id of the specification that is the root of the toc (it is used to "open" the toc list on the current specification).
   *        This id is generated by the specification SpecName
   * @param subTocs map of identifier -> toc for the sub-specifications. The subtocs are inserted where the <subtoc/> tag in present in the body
   *
   * @return the toc of a document
   */
  def tocItemList(body: NodeSeq, rootUrl: DirectoryPath, url: String, id: SpecId, subTocs: Map[SpecId, NodeSeq]): NodeSeq = {
    body.headersTree.
      bottomUp { (h: Header, s: Stream[NodeSeq]) =>
        if (h.isRoot)
      // 'id' is the name of the attribute expected by jstree to "open" the tree on a specific node
          s.reduceNodes.updateHeadAttribute("id", id.toString)
        else if (h.isSubtoc)
          subTocs.getOrElse(h.specId, NodeSeq.Empty) ++ s.reduceNodes
        else
          <li id={h.specId.toString}><a href={FilePath.unsafe(h.anchorName(url)).relativeTo(rootUrl).path}>{h.name}</a>
            { <ul>{s.toSeq}</ul> unless s.toSeq.isEmpty }
          </li>
    }.rootLabel
  }
}

object TableOfContents extends TableOfContents
